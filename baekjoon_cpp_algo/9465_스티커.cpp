///*
//상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다.
//스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다.
//상냥이는 스티커를 이용해 책상을 꾸미려고 한다.
//
//상냥이가 구매한 스티커의 품질은 매우 좋지 않다.
//스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다.
//즉, 뗀 a 스티커의 b, c, d, e 스티커는 사용할 수 없게 된다.
//
//ㅁ ㅁ ㅁ d  ㅁ ㅁ ㅁ ㅁ
//ㅁ ㅁ b  a   c ㅁ ㅁ ㅁ
//ㅁ ㅁ ㅁ e  ㅁ ㅁ ㅁ ㅁ
//ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ
//
//모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고,
//점수의 합이 최대가 되게 스티커를 떼어내려고 한다.
//먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다.
//상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오.
//즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.
//
//위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다.
//가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.
//*/
///*
//풀이
//스티커선택시 그 스티커의 오른쪽 왼쪽 위쪽 아래쪽은 사용할 수 없기때문에
//대각선의 스티커와 그 스티커와 한자리 이상 떨어진 스티커를 선택 가능하다.
//
//예를 들어
//50 10 100 20 40
//30 50 70 10 60 의 점수가 있다고 가정할때
//[0][0]의 자리 스티커는 [1][1],[0][2],[1][2]를 사용 가능하다. 이때 [0][2]는 [1][1]도 사용 가능하기때문에
//선택한 스티커의 대각선 자리와 대각선 옆자리의 스티커중 높은 자리를 선택하면 된다.
//따라서 dp[i][j]=max(dp[(i+1)%2][j-1],dp[(i+1)%2][j-2]) 이다. 
//그래서 가장 높은 값은 Max=max(dp[0][n],dp[1][n])이다.
//*/
//#include <iostream>
//#include <algorithm>
//#include<string.h>
//
//using namespace std;
//
//int main()
//{
//	int t;
//	int n,**arr,**dp;
//	cin >> t;
//	for (int i = 0; i < t; i++)
//	{
//		cin >> n;
//		
//		//동적할당
//		arr = (int**)malloc(sizeof(int*)*2);
//		for (int i = 0; i<2; i++) {
//			arr[i] = (int*)malloc(sizeof(int) * n);
//		}
//		dp = (int**)malloc(sizeof(int*) * 2);
//		for (int i = 0; i<2; i++) {
//			dp[i] = (int*)malloc(sizeof(int) * n);
//		}
//		//초기화
//		for (int i = 0; i<2; i++) {
//			memset(dp[i],0, sizeof(int)* n);
//		}
//
//		for (int j = 0; j < 2; j++)
//		{
//			for (int k = 0; k < n; k++)
//			{
//				cin >> arr[j][k];
//			}
//		}
//		dp[0][0] = arr[0][0];
//		dp[1][0] = arr[1][0];
//		dp[0][1] = dp[1][0] + arr[0][1];
//		dp[1][1] = dp[0][0] + arr[1][1];
//		for (int k = 2; k < n; k++)
//		{
//			for (int j = 0; j < 2; j++)
//			{
//				dp[j][k] = max(arr[j][k]+dp[(j+1)%2][k-1], arr[j][k] + dp[(j + 1)%2][k -2]);
//			}
//		}
//
//		cout << max(dp[0][n-1],dp[1][n-1])<<"\n";
//		
//		for (int j = 0; j<2; j++) {
//			free(arr[j]);
//		}
//		free(arr);
//		for (int j = 0; j<2; j++) {
//			free(dp[j]);
//		}
//		free(dp);
//	}
//}